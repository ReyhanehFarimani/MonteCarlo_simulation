// sanity_check/main_serial.cpp
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <iostream>
#include <iomanip>

#include "../serial_src/initial.h"                 // Particle, SimulationBox
#include "../serial_src/thermodynamic_calculator.h"
#include "../serial_src/cell_list.h"

struct Frame {
    double Lx{0}, Ly{0};
    std::vector<Particle> particles;
};

static bool read_next_xyz_frame(std::ifstream& ifs, Frame& frame) {
    frame = Frame{};
    std::string line;

    // line 1: N
    if (!std::getline(ifs, line)) return false;
    if (line.empty()) return false;
    std::istringstream issN(line);
    int N = 0;
    if (!(issN >> N)) return false;

    // line 2: comment, expected "Lx=... Ly=..."
    if (!std::getline(ifs, line)) return false;
    double Lx=0.0, Ly=0.0;
    {
        std::istringstream iss(line);
        std::string tok;
        // tolerant parser: look for Lx= and Ly=
        while (iss >> tok) {
            if (tok.rfind("Lx=",0)==0) Lx = std::stod(tok.substr(3));
            if (tok.rfind("Ly=",0)==0) Ly = std::stod(tok.substr(3));
        }
    }
    if (Lx <= 0.0 || Ly <= 0.0) {
        // fallback: if not present (e.g., per-rank mode), default to something safe
        // but for our sanity_check we always write Lx/Ly
        std::cerr << "Warning: missing Lx/Ly in XYZ comment; got: \"" << line << "\"\n";
        Lx = 100.0; Ly = 80.0;
    }

    frame.Lx = Lx; frame.Ly = Ly;
    frame.particles.reserve(static_cast<size_t>(N));

    // next N lines: "type x y"
    for (int i = 0; i < N; ++i) {
        if (!std::getline(ifs, line)) return false;
        std::istringstream iss(line);
        std::string type;
        double x=0.0, y=0.0;
        if (!(iss >> type >> x >> y)) return false;
        frame.particles.emplace_back(x, y);
    }
    return true;
}

int main() {
    // Must match the parallel run:
    const double T         = 1.0;

    const double rcut      = 5.0; // big enough for the local choice in parallel; we’ll use CellList anyway


    const PotentialType pot = PotentialType::AthermalStar;
    const double mu    = 0.0;
    const double f     = 8.0;
    const double alpha = 0.3;
    const double A0    = 0.0;
    const double kappa = 0.0;


    // Open the XYZ generated by the MPI run
    std::ifstream ifs("sanity_parallel_traj.xyz");
    if (!ifs.is_open()) {
        std::cerr << "Cannot open sanity_parallel_traj.xyz — run main_parallel first.\n";
        return 1;
    }

    std::ofstream csv("sanity_serial_data.csv", std::ios::out | std::ios::trunc);
    csv << "frame,N,rho,Energy,Virial,Pressure\n";

    ThermodynamicCalculator calc(T, /*press=*/0.0, pot, rcut, mu, f, alpha, A0, kappa);

    Frame frame;
    int frame_id = 0;
    while (read_next_xyz_frame(ifs, frame)) {
        SimulationBox box(frame.Lx, frame.Ly);

        // CellList-based thermo to match the parallel neighbor logic
        const double U = calc.computeTotalEnergyCellList(frame.particles, box);
        const double W = calc.computeTotalVirialCellList(frame.particles, box);
        const double rho = calc.computeDensity(frame.particles, box);
        const double P = calc.computePressureCellList(frame.particles, box);

        csv << frame_id++ << "," << frame.particles.size() << ","
            << std::setprecision(17) << rho << ","
            << U << "," << W << "," << P << "\n";
    }

    csv.close();
    return 0;
}
